
//string to save file-outputs
string fnse = "BEFE_ensemble";
//********************************************************************
real PRESSUREPENALTY = 1.0e-12;

//perturbation of initial conditions

real epsilon1= 1.0e-3;
real epsilon2=(-1)*1.0e-3;
real theta;

//Domain parameters
real H    = 1.0;    //width of box (y-direction)
real L    = 1.0;  //length of channel (x-direction)

//time information
real dT = 0.05; //  time step size
real T0 = 0.0;    //  initial time
real Tf = 1.0;    //  final time

int  TIMELEVELFREQUENCY = 18;   // number of steps between data-output        
int  TOTALTIMELEVELS    = 10;   // (Tf - T0) / (dT * TIMELEVELFREQUENCY)     

//Number of nodes along height and width of channel respectively
int  Ny   = 10;
int  Nx   = 10;
            
//Characteristic values for velocity, length
real uRef = 1.0;
real lRef = L;

//Reynolds number
real Re   = 800.0;

//kinematic viscosity of fluid
real nu   = (uRef*lRef) / Re;

//---------------------------------------------------------------------    

int  TOTALREFINEMENTS = 0;

//---------------------------------------------------------------------   

// solver option
// plotsDEBUG = 0  --  do not produce plots of approximations
// plotsDEBUG = 1  --  print plots to screen
// plotsDEBUG = 2  --  print plots to file
// plotsDEBUG = 3  --  output to data file (uX, uY, p, phi)
int   plotsDEBUG = 2;   

//********************************************************************
//********************************************************************
//********************************************************************

//Define common expressions via macros:

macro dcos(m,x)  (-m*sin(m*x))   //
macro d2cos(m,x) (-m^2*cos(m*x)) //
macro d3cos(m,x) ( m^3*sin(m*x)) //

macro dsin(m,x)  ( m*cos(m*x))   //
macro d2sin(m,x) (-m^2*sin(m*x)) //
macro d3sin(m,x) (-m^3*cos(m*x)) //

//********************************************************************
//********************************************************************
//********************************************************************
//MODEL PARAMETERS 


real omega  = 1.0;

real m0 = 1;
real n0 =   1;   
real tau = Re;
real aalpha = 0;

//EXACT SOLUTION (velocity)

func real g(real t){
      return ((1+theta)*sin(2*t));
}

func real uXTrue(real x, real y, real t){
     return ( -g(t)*cos(m0*x) * sin(n0*y) * exp(-aalpha*t) ) ;
}
func real uYTrue(real x, real y, real t){
     return (  g(t)*sin(m0*x) * cos(n0*y) * exp(-aalpha*t) ) ;
}

func real dXuXTrue(real x, real y, real t){
     return (  -g(t)*dcos(m0,x) * sin(n0*y) * exp(-aalpha*t) ) ;
}
func real dYuXTrue(real x, real y, real t){
     return (  -g(t)*cos(m0*x) * dsin(n0,y) * exp(-aalpha*t) ) ;
}
func real dXuYTrue(real x, real y, real t){
     return (  g(t)*dsin(m0,x) * cos(n0*y) * exp(-aalpha*t) ) ;
}
func real dYuYTrue(real x, real y, real t){
     return (  g(t)*sin(m0*x) * dcos(n0,y) * exp(-aalpha*t) ) ;
}

func real dXXuXTrue(real x, real y, real t){
     return (  -g(t)*d2cos(m0,x) * sin(n0*y) * exp(-aalpha*t)  ) ;
}
func real dYYuXTrue(real x, real y, real t){
     return (  -g(t)*cos(m0*x) * d2sin(n0,y) * exp(-aalpha*t)  ) ;
}
func real dXXuYTrue(real x, real y, real t){
     return (   g(t)*d2sin(m0,x) * cos(n0*y) * exp(-aalpha*t) ) ;
}
func real dYYuYTrue(real x, real y, real t){
     return (   g(t)*sin(m0*x) * d2cos(n0,y) * exp(-aalpha*t) ) ;
}

//---------------------------------
func real pTrue(real x, real y, real t){
     return ( -0.25 *(cos(2*m0*x) + cos(2*n0*y)) * (g(t))^2 );
}
func real dxPTrue(real x, real y, real t){
     return ( -0.25 *(dcos(2*m0,x)) * (g(t))^2 );
}
func real dyPTrue(real x, real y, real t){
     return ( -0.25 * (dcos(2*n0,y)) * (g(t))^2 );
}


//---------------------------------



func real fX(real x, real y, real t){
     return (    
                        -(2*(1+theta)*cos(2*t)+2*g(t)/Re)*cos(m0*x) * sin(n0*y) * exp(-aalpha*t)
           );
}
func real fY(real x, real y, real t){
     return ( (2*(1+theta)*cos(2*t)+2*g(t)/Re)*sin(m0*x) * cos(n0*y) * exp(-aalpha*t) );
}

//-----------------------------------



//-------------------
//  Output flow details

{
    ofstream report(fnse + "_REPORT.txt");
    report << " ***            BEGIN REPORT, Nan Jiang              ***" << endl;
    report << " ***    Back-Forward Euler - Ensemble - NSE    ***" << endl << endl;
    report << "Numerical scheme: " << endl;
    report << " *** Back-Forward Euler time stepping " << endl;
  //  report << " *** Newton nonlinear-iterations (momentum equation for u, p) " << endl << endl;
    report << "PROBLEM SETUP: " << endl;
    report << " Height,            H       = " << H << endl;  
    report << " Length,            L       = " << L << endl;
    report << " # bdry nodes (channel length bottom), N01  = " << Nx << endl;  
    report << " # bdry nodes (channel height right),  N02  = " << Ny << endl;  
    report << " # bdry nodes (channel length top),    N03  = " << Nx << endl;  
    report << " # bdry nodes (channel height left),   N04  = " << Ny << endl;  
    report << "TIME STEPPING DATA: " << endl;
    report << "  Time step size,               dT = " << dT << endl;
    report << "  Initial time,                 T0 = " << T0 << endl;
    report << "  Final time,                   Tf = " << Tf << endl;
  //  report << "  Max iterations,           MAXITS = " << MAXITS << endl;
  //  report << "  Error tolerance,        ERRORTOL = " << ERRORTOL << endl;
    report << "PROBLEM PARAMETERS: " << endl;
    report << "Reynolds number,         Re        = " << Re << endl;
    report << "Reference velocity,      uRef      = " << uRef << endl;
    report << "Reference length,        lRef      = " << lRef << endl;
    report << "Fluid viscosity,         nu        = " << nu << endl << endl;
    report << "SOLVER OPTIONS: " << endl << endl;
}

if (plotsDEBUG == 6){
        {
          ofstream file(fnse + "H.txt");
          file << H << endl;
        }        
        {
          ofstream file(fnse + "L.txt");
          file << L << endl;
        }
        {
          ofstream file(fnse + "Nx.txt");
          file << Nx << endl;
        }        
        {
          ofstream file(fnse + "Ny.txt");
          file << Ny << endl;
        }        
        {
          ofstream file(fnse + "T0.txt");
          file << T0 << endl;
        }
        {
          ofstream file(fnse + "Tf.txt");
          file << Tf << endl;
        }
        {
          ofstream file(fnse + "dT.txt");
          file << dT << endl;
        }
        {
          ofstream file(fnse + "TIMELEVELFREQUENCY.txt");
          file << TIMELEVELFREQUENCY << endl;
        }
        {
          ofstream file(fnse + "TOTALTIMELEVELS.txt");
          file << TOTALTIMELEVELS << endl;
        }
}

//********************************************************************
//********************************************************************
//********************************************************************
//**** CONSTRUCT MESH

//**** Construct mesh (fluid region only)
mesh ThF = square(Nx, Ny, [x*L, y*H]);

//********************************************************************
//********************************************************************
//********************************************************************
//FE-spaces
//Velocity space, C0- piecewise quadratic
  fespace Uh(ThF,P2);
  
//Pressure space, C0- piecewise linear
  fespace Ph(ThF,P1);
  
//fe-functions (velocity space)
// wX,     wY     = current time-step, before filtering 
// uXold,  uYold  = previous time-step
// wXold,  wYold  = previous nonlinear-iterate corresponding to current time-step solution (uX, uY), before filtering
// uX,     uY     = current time-step, after filtering
  Uh uX, uY, uXold, uYold, uX0, uY0, uXave, uYave, uX1, uY1, uX2, uY2;
      
//fe-functions (velocity space, newton update functions)
  Uh kX, kY, uX1F,uY1F,uX2F,uY2F,u1F,u2F,uF;

//fe-functions (velocity space, test functions)
  Uh vX, vY;

//fe-functions (pressure space)
// p     = pressure at current time-step
// pold  = pressure at previous time-step
// pold2 = previous nonlinear-iterate corresponding to current time-step solution p
// lambda = artificial pressure in projection
  Ph p, lambda;
  
//fe-functions (pressure space, newton update functions)
  //Ph r;

//fe-functions (pressure space, test functions)
  Ph q;
  
  real t;
  
  Ph hValue = hTriangle;
  
//********************************************************************
//********************************************************************
//********************************************************************
//Variational Problems (convection)

//Define coHaon expressions via macros:

macro div(u1,u2) ( dx(u1) + dy(u2) ) //
macro dot(u1,u2,v1,v2) ( u1 * v1 + u2 * v2 ) //
macro Ugradv1(u1,u2,v1) ( u1 * dx(v1) + u2 * dy(v1) ) //

macro cc(u1,u2,v1,v2,w1,w2) ( Ugradv1(u1,u2,v1) * w1 + Ugradv1(u1,u2,v2) * w2 ) //
macro cch(u1,u2,v1,v2,w1,w2) ( 0.5*(cc(u1,u2,v1,v2,w1,w2) - cc(u1,u2,w1,w2,v1,v2)) ) //  
macro contract(u1,u2,v1,v2) ( dx(u1) * dx(v1) + dx(u2) * dx(v2) + dy(u1) * dy(v1) + dy(u2) * dy(v2) ) //

//********************************************************************
//********************************************************************
//********************************************************************

problem BEFE([uX,uY,p],[vX,vY,q],solver=UMFPACK)=
  int2d(ThF)(
    (1.0 / dT) * dot(uX,uY,vX,vY) 
    + cch( uXave, uYave, uX, uY, vX, vY)
    + (nu+0.02*uF) * contract(uX, uY, vX, vY)
    - q * div(uX, uY)
    - p * div(vX, vY) 
    + PRESSUREPENALTY * p* q
 )

 +int2d(ThF)(
      -(1.0 / dT) * dot(uXold,uYold,vX,vY) 
      +cch( uXold, uYold, uXold, uYold, vX, vY)
      -cch( uXave, uYave, uXold, uYold, vX, vY)
      -dot(fX(x,y,t-0.5*dT),fY(x,y,t-0.5*dT),vX,vY)
    
   )
 +on( 1, uX = uXTrue(x,y,t), uY = uYTrue(x,y,t) ) 
 +on( 2, uX = uXTrue(x,y,t), uY = uYTrue(x,y,t) ) 
 +on( 3, uX = uXTrue(x,y,t), uY = uYTrue(x,y,t) ) 
 +on( 4, uX = uXTrue(x,y,t), uY = uYTrue(x,y,t) ) ;

//********************************************************************
//********************************************************************
//********************************************************************

//*********** Main SOLVE (BEFE, ensemble) ****************

real[int] h(TOTALREFINEMENTS+1);

//--------------------------------------u2----------------------------------------------------------------
real[int] u2errorULinfL2(TOTALREFINEMENTS+1),   u2errorUL2L2(TOTALREFINEMENTS+1),   u2errorUL2H1semi(TOTALREFINEMENTS+1);
real[int] u2errorGRADPL2L2(TOTALREFINEMENTS+1), u2errorGRADPLinfL2(TOTALREFINEMENTS+1);
real[int] u2normULinfL2(TOTALREFINEMENTS+1),    u2normUL2L2(TOTALREFINEMENTS+1),    u2normUL2H1semi(TOTALREFINEMENTS+1);
real[int] u2normPLinfL2(TOTALREFINEMENTS+1),    u2normPL2L2(TOTALREFINEMENTS+1),    u2normPL2H1semi(TOTALREFINEMENTS+1);
real[int] u2divUmean(TOTALREFINEMENTS+1),       u2divUL2(TOTALREFINEMENTS+1);

//--------------------------------------u1-----------------------------------------------------------------------------
real[int] u1errorULinfL2(TOTALREFINEMENTS+1),   u1errorUL2L2(TOTALREFINEMENTS+1),   u1errorUL2H1semi(TOTALREFINEMENTS+1);
real[int] u1errorGRADPL2L2(TOTALREFINEMENTS+1), u1errorGRADPLinfL2(TOTALREFINEMENTS+1);
real[int] u1normULinfL2(TOTALREFINEMENTS+1),    u1normUL2L2(TOTALREFINEMENTS+1),    u1normUL2H1semi(TOTALREFINEMENTS+1);
real[int] u1normPLinfL2(TOTALREFINEMENTS+1),    u1normPL2L2(TOTALREFINEMENTS+1),    u1normPL2H1semi(TOTALREFINEMENTS+1);
real[int] u1divUmean(TOTALREFINEMENTS+1),       u1divUL2(TOTALREFINEMENTS+1);

//-------------------------------------uave----------------------------------------------------------------
real[int] uaveerrorULinfL2(TOTALREFINEMENTS+1),   uaveerrorUL2L2(TOTALREFINEMENTS+1),   uaveerrorUL2H1semi(TOTALREFINEMENTS+1);
real[int] uaveerrorGRADPL2L2(TOTALREFINEMENTS+1), uaveerrorGRADPLinfL2(TOTALREFINEMENTS+1);
real[int] uavenormULinfL2(TOTALREFINEMENTS+1),    uavenormUL2L2(TOTALREFINEMENTS+1),    uavenormUL2H1semi(TOTALREFINEMENTS+1);
real[int] uavenormPLinfL2(TOTALREFINEMENTS+1),    uavenormPL2L2(TOTALREFINEMENTS+1),    uavenormPL2H1semi(TOTALREFINEMENTS+1);
real[int] uavedivUmean(TOTALREFINEMENTS+1),       uavedivUL2(TOTALREFINEMENTS+1);

//********************************************************************
//********************************************************************

// initialize 
// time t at T0
// time index tracker timeIndex 
// and timeString to store timeIndex as a string

int    timeIndex;
string timeString;

//initialize
real    relError, temp0, temp;
int     numIts;
int     numTotalIts;

string  refNumberString;

//********************************************************************
//********************************************************************

//LOOP #0:  Refinement loop

for (int refNumber = 0; refNumber < (TOTALREFINEMENTS+1); refNumber++){

  refNumberString  = refNumber;
//---------------------------------------u2---------------------------------
  u2errorULinfL2(refNumber)     = 0.0;
  u2errorUL2L2(refNumber)       = 0.0;
  u2errorUL2H1semi(refNumber)   = 0.0;

  u2errorGRADPLinfL2(refNumber) = 0.0;
  u2errorGRADPL2L2(refNumber)   = 0.0;

  u2normULinfL2(refNumber)      = 0.0;
  u2normUL2L2(refNumber)        = 0.0;
  u2normUL2H1semi(refNumber)    = 0.0;
  
  u2normPLinfL2(refNumber)      = 0.0;
  u2normPL2L2(refNumber)        = 0.0;
  u2normPL2H1semi(refNumber)    = 0.0;
//--------------------------------------u1---------------------------------
  u1errorULinfL2(refNumber)     = 0.0;
  u1errorUL2L2(refNumber)       = 0.0;
  u1errorUL2H1semi(refNumber)   = 0.0;

  u1errorGRADPLinfL2(refNumber) = 0.0;
  u1errorGRADPL2L2(refNumber)   = 0.0;

  u1normULinfL2(refNumber)      = 0.0;
  u1normUL2L2(refNumber)        = 0.0;
  u1normUL2H1semi(refNumber)    = 0.0;
  
  u1normPLinfL2(refNumber)      = 0.0;
  u1normPL2L2(refNumber)        = 0.0;
  u1normPL2H1semi(refNumber)    = 0.0;

//---------------------------------uave------------------------------------------
  uaveerrorULinfL2(refNumber)     = 0.0;
  uaveerrorUL2L2(refNumber)       = 0.0;
  uaveerrorUL2H1semi(refNumber)   = 0.0;

  uaveerrorGRADPLinfL2(refNumber) = 0.0;
  uaveerrorGRADPL2L2(refNumber)   = 0.0;

  uavenormULinfL2(refNumber)      = 0.0;
  uavenormUL2L2(refNumber)        = 0.0;
  uavenormUL2H1semi(refNumber)    = 0.0;
  
  uavenormPLinfL2(refNumber)      = 0.0;
  uavenormPL2L2(refNumber)        = 0.0;
  uavenormPL2H1semi(refNumber)    = 0.0;


  if (refNumber > 0){
    ThF = square(((1.5)^refNumber)*Nx, ((1.5)^refNumber)*Ny, [ x*L, y*H]);
    dT = dT/(1.5);
    TIMELEVELFREQUENCY = 1.5*TIMELEVELFREQUENCY;
  }

  t           = T0;
  timeIndex   = 1;
  numTotalIts = 0;

 
  //initialize real-time clock tracker
  real outputCLOCK =   clock();

  
//LOOP #1:  Time evolution for nse
while ( t < (Tf-1.0e-12) ){

  cout << endl << "NUMERICAL TIME LEVEL  t = " << t << endl;	
  cout << endl << " *** real time    = " << clock() << endl;	
  cout << endl << " *** elapsed time = " << clock() - outputCLOCK << endl;
  outputCLOCK = clock();
  
  //Update time-level
  t = t + dT;

 
  
  if(t==T0+dT)
  {
      uF=0;
       theta=0.5*(epsilon1+epsilon2);                 
     uXave=uXTrue(x,y,t-dT);
     uYave=uYTrue(x,y,t-dT);
     theta=epsilon1;
     uXold=uXTrue(x,y,t-dT);
     uYold=uYTrue(x,y,t-dT); 
    
     BEFE;
     uX1=uX;uY1=uY;
     theta=epsilon2;
     uXold=uXTrue(x,y,t-dT);
     uYold=uYTrue(x,y,t-dT);
     BEFE;
     uX2=uX;uY2=uY;
     uXave=0.5*(uX1+uX2);
     uYave=0.5*(uY1+uY2);
    
  }
	
   else
   {	     
     uX1F=uX1-uXave;
     uY1F=uY1-uYave;
     uX2F=uX2-uXave;
     uY2F=uY2-uYave;
     u1F=(uX1F)^2+(uY1F)^2;
     u2F=(uX2F)^2+(uY2F)^2;
     uF=(u1F+u2F)^(1/2);
      uXold=uX1;uYold=uY1;
      theta=epsilon1;
      BEFE;
      uX1=uX;uY1=uY;
      uXold=uX2;uYold=uY2;
      theta=epsilon2;
      BEFE;
      uX2=uX;uY2=uY;
      uXave=0.5*(uX1+uX2);
      uYave=0.5*(uY1+uY2);
      
    
                            

}
 

   
 
  temp      = 1.0;
  relError  = 1.0;
  numIts    = 0;  
  

  
  if( timeIndex == TIMELEVELFREQUENCY ){
    timeString = t;
    timeIndex = 1;
    
    if ( plotsDEBUG == 1 ){
      plot(p, [uX,uY], fill=1, cmm="Velocity, pressure fields:  time level = " + timeString,wait=1,value=1);
    }
    else if (plotsDEBUG == 2) {
      plot(p,[uX,uY], value=1, fill=1, ps=fnse + "_" + timeString + ".eps"); 
    }
    else if (plotsDEBUG == 3) {
      {
        ofstream file(fnse + "_velocityX_REF_" + refNumberString + "_TIME_" + timeString + ".txt");
        file << uX[] << endl;
      }
      {
        ofstream file(fnse + "_velocityY_REF_" + refNumberString + "_TIME_" + timeString + ".txt");
        file << uY[] << endl;
      }
      {
        ofstream file(fnse + "_pressure_REF_" + refNumberString + "_TIME_" + timeString + ".txt");
        file << p[] << endl;
      }
    }
  }
  else{
     timeIndex++;
  }
  
   //uX=uXave; uY=uYave;

//----------------------------  u2 ---------------------------------------------------
  theta=epsilon2;
  temp = sqrt( int2d(ThF)( (uX2-(uXTrue(x,y,t)))^2 + (uY2-(uYTrue(x,y,t)))^2 ) );
  if ( temp > u2errorULinfL2(refNumber) ){
    u2errorULinfL2(refNumber) = temp;
  }

  u2errorUL2L2(refNumber)     
  =  u2errorUL2L2(refNumber)
     + int2d(ThF)( (uX2-(uXTrue(x,y,t)))^2 + (uY2-(uYTrue(x,y,t)))^2 );

  u2errorUL2H1semi(refNumber) 
  = u2errorUL2H1semi(refNumber)
    + int2d(ThF)( (dx(uX2)-(dXuXTrue(x,y,t)))^2 + (dy(uY2)-(dYuYTrue(x,y,t)))^2 
                 +(dy(uX2)-(dYuXTrue(x,y,t)))^2 + (dx(uY2)-(dXuYTrue(x,y,t)))^2  );

  
  temp = sqrt( int2d(ThF)( (uX2)^2 + (uY2)^2 ) );
  if ( temp > u2normULinfL2(refNumber) ){
    u2normULinfL2(refNumber) = temp;
  }

  temp = sqrt( int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2 ) );
  if ( temp > u2errorGRADPLinfL2(refNumber) ){
    u2errorGRADPLinfL2(refNumber) = temp;
  }
   
  u2errorGRADPL2L2(refNumber)     
  =  u2errorGRADPL2L2(refNumber)
     + int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2  );
     
  u2normUL2L2(refNumber)        
  =  u2normUL2L2(refNumber)
     + int2d(ThF)( (uX2)^2 + (uY2)^2 );

  u2normUL2H1semi(refNumber)    
  =  u2normUL2H1semi(refNumber)
     + int2d(ThF)( (dx(uX2))^2 + (dy(uY2))^2 + (dy(uX2))^2 + (dx(uY2))^2  );
                               
  temp = sqrt( int2d(ThF)( (p)^2 ) );
  if ( temp > u2normPLinfL2(refNumber) ){
    u2normPLinfL2(refNumber) = temp;
  }

  u2normPL2L2(refNumber)      
  =  u2normPL2L2(refNumber)
     + int2d(ThF)( (p)^2 );

  u2normPL2H1semi(refNumber)  
  =  u2normPL2H1semi(refNumber)
     + int2d(ThF)( (dx(p))^2 + (dy(p))^2 );

//--------------------------------------  u1 -----------------------------------

theta=epsilon1;
temp = sqrt( int2d(ThF)( (uX1-(uXTrue(x,y,t)))^2 + (uY1-(uYTrue(x,y,t)))^2 ) );
  if ( temp > u1errorULinfL2(refNumber) ){
    u1errorULinfL2(refNumber) = temp;
  }

  u1errorUL2L2(refNumber)     
  =  u1errorUL2L2(refNumber)
     + int2d(ThF)( (uX1-(uXTrue(x,y,t)))^2 + (uY1-(uYTrue(x,y,t)))^2 );

  u1errorUL2H1semi(refNumber) 
  = u1errorUL2H1semi(refNumber)
    + int2d(ThF)( (dx(uX1)-(dXuXTrue(x,y,t)))^2 + (dy(uY1)-(dYuYTrue(x,y,t)))^2 
                 +(dy(uX1)-(dYuXTrue(x,y,t)))^2 + (dx(uY1)-(dXuYTrue(x,y,t)))^2  );

  
  temp = sqrt( int2d(ThF)( (uX1)^2 + (uY1)^2 ) );
  if ( temp > u1normULinfL2(refNumber) ){
    u1normULinfL2(refNumber) = temp;
  }

  temp = sqrt( int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2 ) );
  if ( temp > u1errorGRADPLinfL2(refNumber) ){
    u1errorGRADPLinfL2(refNumber) = temp;
  }
   
  u1errorGRADPL2L2(refNumber)     
  =  u1errorGRADPL2L2(refNumber)
     + int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2  );
     
  u1normUL2L2(refNumber)        
  =  u1normUL2L2(refNumber)
     + int2d(ThF)( (uX1)^2 + (uY1)^2 );

  u1normUL2H1semi(refNumber)    
  =  u1normUL2H1semi(refNumber)
     + int2d(ThF)( (dx(uX1))^2 + (dy(uY1))^2 + (dy(uX1))^2 + (dx(uY1))^2  );
                               
  temp = sqrt( int2d(ThF)( (p)^2 ) );
  if ( temp > u1normPLinfL2(refNumber) ){
    u1normPLinfL2(refNumber) = temp;
  }

  u1normPL2L2(refNumber)      
  =  u1normPL2L2(refNumber)
     + int2d(ThF)( (p)^2 );

  u1normPL2H1semi(refNumber)  
  =  u1normPL2H1semi(refNumber)
     + int2d(ThF)( (dx(p))^2 + (dy(p))^2 );
//------------------------------------  uave -----------------------------------------------------------

theta=0;
temp = sqrt( int2d(ThF)( (uXave-uXTrue(x,y,t))^2 + (uYave-uYTrue(x,y,t))^2 ) );
  if ( temp > uaveerrorULinfL2(refNumber) ){
    uaveerrorULinfL2(refNumber) = temp;
  }

  uaveerrorUL2L2(refNumber)     
  =  uaveerrorUL2L2(refNumber)
     + int2d(ThF)( (uXave-uXTrue(x,y,t))^2 + (uYave-uYTrue(x,y,t))^2 );

  uaveerrorUL2H1semi(refNumber) 
  = uaveerrorUL2H1semi(refNumber)
    + int2d(ThF)( (dx(uXave)-dXuXTrue(x,y,t))^2 + (dy(uYave)-dYuYTrue(x,y,t))^2 
                 +(dy(uXave)-dYuXTrue(x,y,t))^2 + (dx(uYave)-dXuYTrue(x,y,t))^2  );

  
  temp = sqrt( int2d(ThF)( (uXave)^2 + (uYave)^2 ) );
  if ( temp > uavenormULinfL2(refNumber) ){
    uavenormULinfL2(refNumber) = temp;
  }

  temp = sqrt( int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2 ) );
  if ( temp > uaveerrorGRADPLinfL2(refNumber) ){
    uaveerrorGRADPLinfL2(refNumber) = temp;
  }
   
  uaveerrorGRADPL2L2(refNumber)     
  =  uaveerrorGRADPL2L2(refNumber)
     + int2d(ThF)( (dx(p)-dxPTrue(x,y,t))^2 + (dy(p)-dyPTrue(x,y,t))^2  );
     
  uavenormUL2L2(refNumber)        
  =  uavenormUL2L2(refNumber)
     + int2d(ThF)( (uXave)^2 + (uYave)^2 );

  uavenormUL2H1semi(refNumber)    
  =  uavenormUL2H1semi(refNumber)
     + int2d(ThF)( (dx(uXave))^2 + (dy(uYave))^2 + (dy(uXave))^2 + (dx(uYave))^2  );
                               
  temp = sqrt( int2d(ThF)( (p)^2 ) );
  if ( temp > uavenormPLinfL2(refNumber) ){
    uavenormPLinfL2(refNumber) = temp;
  }

  uavenormPL2L2(refNumber)      
  =  uavenormPL2L2(refNumber)
     + int2d(ThF)( (p)^2 );

  uavenormPL2H1semi(refNumber)  
  =  uavenormPL2H1semi(refNumber)
     + int2d(ThF)( (dx(p))^2 + (dy(p))^2 );
} // END WHILE LOOP #1 (time stepping)

h(refNumber) = hValue[].max;

//--------------------------------------u2------------------------------------------
  u2errorUL2L2(refNumber)       = sqrt(dT*u2errorUL2L2(refNumber));
  u2errorUL2H1semi(refNumber)   = sqrt(dT*u2errorUL2H1semi(refNumber));

  u2errorGRADPL2L2(refNumber)   = sqrt(dT*u2errorGRADPL2L2(refNumber));

  u2normUL2L2(refNumber)        = sqrt(dT*u2normUL2L2(refNumber));
  u2normUL2H1semi(refNumber)    = sqrt(dT*u2normUL2H1semi(refNumber));

  u2normPL2L2(refNumber)        = sqrt(dT*u2normPL2L2(refNumber));
  u2normPL2H1semi(refNumber)    = sqrt(dT*u2normPL2H1semi(refNumber));

  u2divUmean(refNumber)         = int2d(ThF)(dx(uX2) + dy(uY2));
  u2divUL2(refNumber)           = sqrt(int2d(ThF)( (dx(uX2) + dy(uY2))*(dx(uX2) + dy(uY2)) ));
//------------------------------------u1-----------------------------------------------
  u1errorUL2L2(refNumber)       = sqrt(dT*u1errorUL2L2(refNumber));
  u1errorUL2H1semi(refNumber)   = sqrt(dT*u1errorUL2H1semi(refNumber));

  u1errorGRADPL2L2(refNumber)   = sqrt(dT*u1errorGRADPL2L2(refNumber));

  u1normUL2L2(refNumber)        = sqrt(dT*u1normUL2L2(refNumber));
  u1normUL2H1semi(refNumber)    = sqrt(dT*u1normUL2H1semi(refNumber));

  u1normPL2L2(refNumber)        = sqrt(dT*u1normPL2L2(refNumber));
  u1normPL2H1semi(refNumber)    = sqrt(dT*u1normPL2H1semi(refNumber));

  u1divUmean(refNumber)         = int2d(ThF)(dx(uX1) + dy(uY1));
  u1divUL2(refNumber)           = sqrt(int2d(ThF)( (dx(uX1) + dy(uY1))*(dx(uX1) + dy(uY1)) ));
//--------------------------------------uave--------------------------------------------
  uaveerrorUL2L2(refNumber)       = sqrt(dT*uaveerrorUL2L2(refNumber));
  uaveerrorUL2H1semi(refNumber)   = sqrt(dT*uaveerrorUL2H1semi(refNumber));

  uaveerrorGRADPL2L2(refNumber)   = sqrt(dT*uaveerrorGRADPL2L2(refNumber));

  uavenormUL2L2(refNumber)        = sqrt(dT*uavenormUL2L2(refNumber));
  uavenormUL2H1semi(refNumber)    = sqrt(dT*uavenormUL2H1semi(refNumber));

  uavenormPL2L2(refNumber)        = sqrt(dT*uavenormPL2L2(refNumber));
  uavenormPL2H1semi(refNumber)    = sqrt(dT*uavenormPL2H1semi(refNumber));

  uavedivUmean(refNumber)         = int2d(ThF)(dx(uXave) + dy(uYave));
  uavedivUL2(refNumber)           = sqrt(int2d(ThF)( (dx(uXave) + dy(uYave))*(dx(uXave) + dy(uYave)) ));

//-------------------------------------------------------------------------------------------
  {
   ofstream report(fnse + "_REPORT.txt",append);
   report << endl << endl;
   report << "***********************************************************************" << endl;
   report << "  Total # nonlinear-iterations     = " << numTotalIts << endl;
   report << endl << "Refinement # " << refNumber << endl;
   report << "  h                = " << h << endl << endl;

//-----------------------------------u2----------------------------------------
   report << "  u2errorULinfL2     = " << u2errorULinfL2 << endl;
   report << "  u2errorUL2L2       = " << u2errorUL2L2 << endl;
   report << "  u2errorUL2H1semi   = " << u2errorUL2H1semi << endl << endl;
   report << "  u2errorGRADPLinfL2 = " << u2errorGRADPLinfL2 << endl;
   report << "  u2errorGRADPL2L2   = " << u2errorGRADPL2L2 << endl << endl;
   report << "  u2normULinfL2      = " << u2normULinfL2 << endl;
   report << "  u2normUL2L2        = " << u2normUL2L2 << endl;
   report << "  u2normUL2H1semi    = " << u2normUL2H1semi << endl << endl;
   report << "  u2normPLinfL2      = " << u2normPLinfL2 << endl;
   report << "  u2normPL2L2        = " << u2normPL2L2 << endl;
   report << "  u2normPL2H1semi    = " << u2normPL2H1semi << endl << endl;
   report << "  u2divUmean         = " << u2divUmean << endl;
   report << "  u2divUL2           = " << u2divUL2 << endl << endl;
//-----------------------------------u1-------------------------------------------
   report << "  u1errorULinfL2     = " << u1errorULinfL2 << endl;
   report << "  u1errorUL2L2       = " << u1errorUL2L2 << endl;
   report << "  u1errorUL2H1semi   = " << u1errorUL2H1semi << endl << endl;
   report << "  u1errorGRADPLinfL2 = " << u1errorGRADPLinfL2 << endl;
   report << "  u1errorGRADPL2L2   = " << u1errorGRADPL2L2 << endl << endl;
   report << "  u1normULinfL2      = " << u1normULinfL2 << endl;
   report << "  u1normUL2L2        = " << u1normUL2L2 << endl;
   report << "  u1normUL2H1semi    = " << u1normUL2H1semi << endl << endl;
   report << "  u1normPLinfL2      = " << u1normPLinfL2 << endl;
   report << "  u1normPL2L2        = " << u1normPL2L2 << endl;
   report << "  u1normPL2H1semi    = " << u1normPL2H1semi << endl << endl;
   report << "  u1divUmean         = " << u1divUmean << endl;
   report << "  u1divUL2           = " << u1divUL2 << endl << endl;
//------------------------------------uave---------------------------------------
   report << "  uaveerrorULinfL2     = " << uaveerrorULinfL2 << endl;
   report << "  uaveerrorUL2L2       = " << uaveerrorUL2L2 << endl;
   report << "  uaveerrorUL2H1semi   = " << uaveerrorUL2H1semi << endl << endl;
   report << "  uaveerrorGRADPLinfL2 = " << uaveerrorGRADPLinfL2 << endl;
   report << "  uaveerrorGRADPL2L2   = " << uaveerrorGRADPL2L2 << endl << endl;
   report << "  uavenormULinfL2      = " << uavenormULinfL2 << endl;
   report << "  uavenormUL2L2        = " << uavenormUL2L2 << endl;
   report << "  uavenormUL2H1semi    = " << uavenormUL2H1semi << endl << endl;
   report << "  uavenormPLinfL2      = " << uavenormPLinfL2 << endl;
   report << "  uavenormPL2L2        = " << uavenormPL2L2 << endl;
   report << "  uavenormPL2H1semi    = " << uavenormPL2H1semi << endl << endl;
   report << "  uavedivUmean         = " << uavedivUmean << endl;
   report << "  uavedivUL2           = " << uavedivUL2 << endl << endl;
  
  }

  
} // END FOR LOOP #0 (refinement)
